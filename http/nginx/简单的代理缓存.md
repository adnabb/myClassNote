# 1. 简单的代理缓存

下面我们来完成一个简单的nginx代理缓存服务。

（1）修改nginx配置；
（2）修改node配置。

<!-- TOC -->

- [1. 简单的代理缓存](#1-%e7%ae%80%e5%8d%95%e7%9a%84%e4%bb%a3%e7%90%86%e7%bc%93%e5%ad%98)
  - [1.1. （1）nginx缓存配置](#11-1nginx%e7%bc%93%e5%ad%98%e9%85%8d%e7%bd%ae)
  - [1.2. （2）node服务](#12-2node%e6%9c%8d%e5%8a%a1)
  - [1.3. 结果展示](#13-%e7%bb%93%e6%9e%9c%e5%b1%95%e7%a4%ba)
  - [1.4. 其他配置](#14-%e5%85%b6%e4%bb%96%e9%85%8d%e7%bd%ae)
    - [1.4.1. private](#141-private)
    - [1.4.2. vary](#142-vary)

<!-- /TOC -->


## 1.1. （1）nginx缓存配置

test.conf
```conf
# newly added
proxy_cache_path  cache levels=1:2 keys_zone=my_cache:10m;

server {
    listen          80;
    server_name     vivi.com;

    location / {
        # newly added
        proxy_cache     my_cache;
        proxy_pass http://localhost:8080;
        proxy_set_header Host $host;
    }
}
```

在之前的基础上新增了两行代码

```conf
# proxy_cache_path位于http内
# cache：将缓存的内容保存到nginx根目录的cache文件夹内（可自定义）
# levels=1:2 将缓存的内容以两层文件夹进行保存
# keys_zome=my_cache:10m 缓存命名为my_cache，大小为10兆
proxy_cache_path  cache levels=1:2 keys_zone=my_cache:10m;
```

```conf
# proxy_cache位于location内
# 其值为上面的缓存命名 my_cache
proxy_cache     my_cache;
```

修改完成后先检查nginx配置是否正确；成功后重启nginx。

## 1.2. （2）node服务

test.html
```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>nginx</title>
</head>

<body>
    Hi~This is a nginx page.
    <div id="container">request pending...</div>
</body>
<script>
    const div = document.querySelector('#container');

    fetch('/data').then((res) => {
        return res.text();
    }).then((data) => {
        div.innerText = data;
    }).catch((err) => {
        div.innerText = 'failed';
        console.error(err);
    });
</script>

</html>
```

```js
const http = require('http');
const fs = require('fs');

const port = 8080;
const host = 'localhost';

// newly added
const wait = (seconds) => {
    return new Promise((resolve) => {
        setTimeout(() => {
            resolve();
        }, seconds * 1000);
    });
};

const server = http.createServer((req, res) => {
    if (req.url === '/') {
        res.writeHead(200, {
            'Content-Type': 'text/html',
        })
        res.end(fs.readFileSync('test.html', 'utf8'));
    }
    
    // newly added
    if(req.url === '/data') {
        res.writeHead(200, {
            'Content-Type': 'text/plain',
            'Cache-Control': 's-maxage=10',
        });

        wait(2).then(() => {
            res.end('succeed!');
        });
    }
});

server.listen(port, host, () => {
    console.log(`server is running on http://${host}:${port}`);
});
```

为了在页面中清除的看到是否命中了缓存服务器，我们创建了一个wait函数（如下）

```js
const wait = (seconds) => {
    return new Promise((resolve) => {
        setTimeout(() => {
            resolve();
        }, seconds * 1000);
    });
};

……

res.writeHead(200, {
    'Content-Type': 'text/plain',
    // 在`/data`请求头中，我们加入了`'Cache-Control': 's-maxage=10',`代表着代理缓存10之后才过期；
    'Cache-Control': 's-maxage=10',
});

wait(2).then(() => {
    res.end('succeed!');
});
```

当页面请求`/data`之后，会等待两秒钟之后返回内容`succeed!`。

**注意：当用nginx作为缓存代理服务器时，s-maxage的优先级高于max-age。**

## 1.3. 结果展示


第一次请求

![1b4a618ad75790e18.png](https://www.imageoss.com/images/2019/12/31/1b4a618ad75790e18.png)

10秒内的第二次请求

![208e24be307ac7b5c.png](https://www.imageoss.com/images/2019/12/31/208e24be307ac7b5c.png)

10秒外的第三次请求

![1b4a618ad75790e18.png](https://www.imageoss.com/images/2019/12/31/1b4a618ad75790e18.png)

## 1.4. 其他配置

### 1.4.1. private

### 1.4.2. vary